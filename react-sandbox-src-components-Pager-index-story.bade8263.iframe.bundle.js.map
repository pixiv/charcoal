{"version":3,"file":"react-sandbox-src-components-Pager-index-story.bade8263.iframe.bundle.js","mappings":";;;;;;;;;;;AAuMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;;;AAGA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;;;AAGA;;;;;;AAUA;;AAEA;;;AAKA","sources":["webpack://charcoal-ui/./packages/react-sandbox/src/components/Pager/index.tsx"],"sourcesContent":["import { memo, useCallback, useDebugValue, useMemo } from 'react'\n\nimport styled, { css } from 'styled-components'\nimport warning from 'warning'\nimport DotsIcon from '../icons/DotsIcon'\nimport WedgeIcon, { WedgeDirection } from '../icons/WedgeIcon'\nimport { useComponentAbstraction } from '../../_lib/ComponentAbstraction'\n\nfunction usePagerWindow(\n  page: number,\n  pageCount: number,\n  pageRangeDisplayed = 7\n) {\n  // ページャーのリンク生成例:\n  //\n  //     < [ 1 ] [*2*] [ 3 ] [ 4 ] [ 5 ] [ 6 ] [ 7 ] >\n  //\n  //     < [ 1 ] [ 2 ] [ 3 ] [*4*] [ 5 ] [ 6 ] [ 7 ] >\n  //\n  //     < [ 1 ]  ...  [ 4 ] [*5*] [ 6 ] [ 7 ] [ 8 ] >\n  //\n  //     < [ 1 ]  ...  [ 99 ] [*100*] [ 101 ] [ 102 ] [ 103 ] >\n  //\n  //     < [ 1 ]  ...  [ 99 ] [ 100 ] [ 101 ] [ 102 ] [*103*]\n  //\n  //       [*1*] [ 2 ] >\n  //\n  // デザインの意図: 前後移動時のカーソル移動を最小限にする。\n\n  if (process.env.NODE_ENV !== 'production') {\n    warning((page | 0) === page, `\\`page\\` must be integer (${page})`)\n    warning(\n      (pageCount | 0) === pageCount,\n      `\\`pageCount\\` must be integer (${pageCount})`\n    )\n    warning(\n      (pageRangeDisplayed | 0) === pageRangeDisplayed,\n      `\\`pageRangeDisplayed\\` must be integer (${pageRangeDisplayed})`\n    )\n    warning(pageRangeDisplayed > 2, `\\`windowSize\\` must be greater than 2`)\n  }\n\n  const window = useMemo(() => {\n    const visibleFirstPage = 1\n    const visibleLastPage = Math.min(\n      pageCount,\n      Math.max(page + Math.floor(pageRangeDisplayed / 2), pageRangeDisplayed)\n    )\n\n    if (visibleLastPage <= pageRangeDisplayed) {\n      // 表示範囲が1-7ページなら省略は無い。\n      return Array.from(\n        { length: 1 + visibleLastPage - visibleFirstPage },\n        (_, i) => visibleFirstPage + i\n      )\n    } else {\n      const start = visibleLastPage - (pageRangeDisplayed - 1) + 2\n      return [\n        // 表示範囲が1-7ページを超えるなら、\n        // - 1ページ目は固定で表示する\n        visibleFirstPage,\n        // - 2ページ目から現在のページの直前までは省略する\n        '...' as const,\n        ...Array.from(\n          { length: 1 + visibleLastPage - start },\n          (_, i) => start + i\n        ),\n      ]\n    }\n  }, [page, pageCount, pageRangeDisplayed])\n\n  useDebugValue(window)\n\n  return window\n}\n\ninterface CommonProps {\n  page: number\n  pageCount: number\n  pageRangeDisplayed?: number\n}\n\nexport interface PagerProps extends CommonProps {\n  onChange(newPage: number): void\n}\n\n// this pager is just regular buttons; for links use LinkPager\nexport default memo(function Pager({\n  page,\n  pageCount,\n  pageRangeDisplayed,\n  onChange,\n}: PagerProps) {\n  // TODO: refactor Pager and LinkPager to use a common parent component\n  const window = usePagerWindow(page, pageCount, pageRangeDisplayed)\n  const makeClickHandler = useCallback(\n    (value: number) => () => {\n      onChange(value)\n    },\n    [onChange]\n  )\n\n  const hasNext = page < pageCount\n  const hasPrev = page > 1\n  return (\n    <PagerContainer>\n      <CircleButton\n        type=\"button\"\n        hidden={!hasPrev}\n        disabled={!hasPrev}\n        onClick={makeClickHandler(Math.max(1, page - 1))}\n        noBackground\n      >\n        <WedgeIcon size={16} direction={WedgeDirection.Left} />\n      </CircleButton>\n      {window.map((p) =>\n        p === '...' ? (\n          <Spacer key={p}>\n            <DotsIcon size={20} />\n          </Spacer>\n        ) : p === page ? (\n          // we remove the onClick but don't mark it as disabled to preserve keyboard focus\n          // not doing so causes the focus ring to flicker in and out of existence\n          <CircleButton key={p} type=\"button\" aria-current>\n            <Text>{p}</Text>\n          </CircleButton>\n        ) : (\n          <CircleButton key={p} type=\"button\" onClick={makeClickHandler(p)}>\n            <Text>{p}</Text>\n          </CircleButton>\n        )\n      )}\n      <CircleButton\n        type=\"button\"\n        hidden={!hasNext}\n        disabled={!hasNext}\n        onClick={makeClickHandler(Math.min(pageCount, page + 1))}\n        noBackground\n      >\n        <WedgeIcon size={16} direction={WedgeDirection.Right} />\n      </CircleButton>\n    </PagerContainer>\n  )\n})\n\nexport interface LinkPagerProps extends CommonProps {\n  makeUrl(page: number): string\n}\n\nexport function LinkPager({\n  page,\n  pageCount,\n  pageRangeDisplayed,\n  makeUrl,\n}: LinkPagerProps) {\n  const { Link } = useComponentAbstraction()\n  const window = usePagerWindow(page, pageCount, pageRangeDisplayed)\n\n  const hasNext = page < pageCount\n  const hasPrev = page > 1\n  return (\n    <PagerContainer>\n      <Link to={makeUrl(Math.max(1, page - 1))}>\n        <CircleButton hidden={!hasPrev} aria-disabled={!hasPrev} noBackground>\n          <WedgeIcon size={16} direction={WedgeDirection.Left} />\n        </CircleButton>\n      </Link>\n      {window.map((p) =>\n        p === '...' ? (\n          <Spacer key={p}>\n            <DotsIcon size={20} subLink />\n          </Spacer>\n        ) : p === page ? (\n          <CircleButton key={p} type=\"button\" aria-current>\n            <Text>{p}</Text>\n          </CircleButton>\n        ) : (\n          <Link key={p} to={makeUrl(p)}>\n            <CircleButton type=\"button\">\n              <Text>{p}</Text>\n            </CircleButton>\n          </Link>\n        )\n      )}\n      <Link to={makeUrl(Math.min(pageCount, page + 1))}>\n        <CircleButton hidden={!hasNext} aria-disabled={!hasNext} noBackground>\n          <WedgeIcon size={16} direction={WedgeDirection.Right} />\n        </CircleButton>\n      </Link>\n    </PagerContainer>\n  )\n}\n\nconst PagerContainer = styled.nav`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n`\n\nconst CircleButton = styled.button<{ noBackground?: boolean }>`\n  font-size: 1rem;\n  line-height: calc(1em + 8px);\n  text-decoration: none;\n  border: none;\n  outline: none;\n  touch-action: manipulation;\n  user-select: none;\n  transition: box-shadow 0.2s ease 0s, color 0.2s ease 0s,\n    background 0.2s ease 0s, opacity 0.2s ease 0s;\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  box-sizing: content-box;\n  min-width: 24px;\n  min-height: 24px;\n  padding: 8px;\n  cursor: pointer;\n  font-weight: bold;\n  /* HACK:\n   * Safari doesn't correctly repaint the elements when they're reordered in response to interaction.\n   * This forces it to repaint them. This doesn't work if put on the parents either, has to be here.\n   */\n  /* stylelint-disable-next-line property-no-vendor-prefix */\n  -webkit-transform: translateZ(0);\n\n  &[hidden] {\n    visibility: hidden;\n    display: block;\n  }\n\n  border-radius: 48px;\n\n  background: transparent;\n  color: ${({ theme }) => theme.color.text3};\n\n  &:hover {\n    background: ${({ theme }) => theme.color.surface3};\n    color: ${({ theme }) => theme.color.text2};\n  }\n\n  &[aria-current] {\n    background-color: ${({ theme }) => theme.color.surface6};\n    color: ${({ theme }) => theme.color.text5};\n  }\n\n  &[aria-current]:hover {\n    background-color: ${({ theme }) => theme.color.surface6};\n    color: ${({ theme }) => theme.color.text5};\n  }\n\n  ${({ noBackground = false }) =>\n    noBackground &&\n    css`\n      /* stylelint-disable-next-line no-duplicate-selectors */\n      &:hover {\n        background: transparent;\n      }\n    `}\n`\n\nconst Spacer = styled(CircleButton).attrs({ type: 'button', disabled: true })`\n  && {\n    color: ${({ theme }) => theme.color.text3};\n    background: none;\n  }\n`\n\nconst Text = 'span'\n"],"names":[],"sourceRoot":""}