{"version":3,"file":"react-sandbox-src-components-Carousel-index-story.e3cc2703.iframe.bundle.js","mappings":";;;;;;;;;;AA8TA;;;;AAMA;;;;AAOA;;;AAIA;AACA;;;;;;;AASA;;;;;;;;;;AAYA;;;AAGA;AA/VA;AAmWA;AAnWA;;;;AAAA;;AA0WA;AA1WA;;AA+WA;;;AA/WA;;;AAuXA;;AAvXA;AAAA;;;AAAA;AA8XA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtUA;AAAA;;AASA;;AAEA;AAGA;;;;;;;;;;;;;;;;;AAiBA;AACA;AAEA;;;AAGA;AACA;AAEA;;;AAGA;;;;;AASA;;;;AA2BA;AAEA;;;;AAIA;AAEA;;AAIA;;;;;;AClHA;AAEA;AACA;;;;AAUA","sources":["webpack://charcoal-ui/./packages/react-sandbox/src/components/Carousel/index.tsx","webpack://charcoal-ui/./packages/react-sandbox/src/components/CarouselButton/index.tsx","webpack://charcoal-ui/./packages/react-sandbox/src/components/icons/Base.tsx"],"sourcesContent":["import { useEffect, useState, useCallback, useRef } from 'react'\nimport * as React from 'react'\nimport { animated, useSpring } from 'react-spring'\nimport styled, { css } from 'styled-components'\nimport { useDebounceAnimationState } from '../../foundation/hooks'\nimport { passiveEvents, isEdge } from '../../foundation/support'\nimport { useIsomorphicLayoutEffect } from '../../hooks'\nimport CarouselButton, { Direction } from '../CarouselButton'\n\nexport const GRADIENT_WIDTH = 72\n/**\n * カルーセル系のスクロール量の定数\n *\n * @example\n * const scrollAmount = containerElm.clientWidth * SCROLL_AMOUNT_COEF\n */\nexport const SCROLL_AMOUNT_COEF = 0.75\n\ninterface ScrollProps {\n  align?: 'center' | 'left' | 'right'\n  offset?: number\n}\n\nexport interface CarouselBaseAppearanceProps {\n  buttonOffset?: number\n  buttonPadding?: number\n  bottomOffset?: number\n  defaultScroll?: ScrollProps\n}\n\nexport type CarouselGradientProps =\n  | { hasGradient?: false }\n  | {\n      hasGradient: true\n      fadeInGradient?: boolean\n    }\n\ntype CarouselAppearanceProps = CarouselBaseAppearanceProps &\n  CarouselGradientProps\n\ntype Props = CarouselAppearanceProps & {\n  onScroll?: (left: number) => void\n  onResize?: (width: number) => void\n  children: React.ReactNode\n  centerItems?: boolean\n  onScrollStateChange?: (canScroll: boolean) => void\n  scrollAmountCoef?: number\n}\n\nexport interface CarouselHandlerRef {\n  resetScroll(): void\n}\n\nexport default function Carousel({\n  buttonOffset = 0,\n  buttonPadding = 16,\n  bottomOffset = 0,\n  defaultScroll: { align = 'left', offset: scrollOffset = 0 } = {},\n  onScroll,\n  onResize,\n  children,\n  centerItems,\n  onScrollStateChange,\n  scrollAmountCoef = SCROLL_AMOUNT_COEF,\n  ...options\n}: Props) {\n  // スクロール位置を保存する\n  // アニメーション中の場合は、アニメーション終了時のスクロール位置が保存される\n  const [scrollLeft, setScrollLeft] = useDebounceAnimationState(0)\n  // アニメーション中かどうか\n  const animation = useRef(false)\n  // スクロール可能な領域を保存する\n  const [maxScrollLeft, setMaxScrollLeft] = useState(0)\n  // 左右のボタンの表示状態を保存する\n  const [leftShow, setLeftShow] = useState(false)\n  const [rightShow, setRightShow] = useState(false)\n\n  // const [props, set, stop] = useSpring(() => ({\n  //   scroll: 0\n  // }))\n  const [styles, set] = useSpring(() => ({ scroll: 0 }))\n\n  const ref = useRef<HTMLDivElement>(null)\n  const visibleAreaRef = useRef<HTMLDivElement>(null)\n  const innerRef = useRef<HTMLUListElement>(null)\n\n  const handleRight = useCallback(() => {\n    if (visibleAreaRef.current === null) {\n      return\n    }\n    const { clientWidth } = visibleAreaRef.current\n    // スクロール領域を超えないように、アニメーションを開始\n    // アニメーション中にアニメーションが開始されたときに、アニメーション終了予定の位置から再度計算するようにする\n    const scroll = Math.min(\n      scrollLeft + clientWidth * scrollAmountCoef,\n      maxScrollLeft\n    )\n    setScrollLeft(scroll, true)\n    set({ scroll, from: { scroll: scrollLeft }, reset: !animation.current })\n    animation.current = true\n  }, [\n    animation,\n    maxScrollLeft,\n    scrollLeft,\n    set,\n    scrollAmountCoef,\n    setScrollLeft,\n  ])\n\n  const handleLeft = useCallback(() => {\n    if (visibleAreaRef.current === null) {\n      return\n    }\n    const { clientWidth } = visibleAreaRef.current\n    const scroll = Math.max(scrollLeft - clientWidth * scrollAmountCoef, 0)\n    setScrollLeft(scroll, true)\n    set({ scroll, from: { scroll: scrollLeft }, reset: !animation.current })\n    animation.current = true\n  }, [animation, scrollLeft, set, scrollAmountCoef, setScrollLeft])\n\n  // スクロール可能な場合にボタンを表示する\n  // scrollLeftが変化したときに処理する (アニメーション開始時 & 手動スクロール時)\n  useEffect(() => {\n    const newLeftShow = scrollLeft > 0\n    const newRightShow = scrollLeft < maxScrollLeft && maxScrollLeft > 0\n    if (newLeftShow !== leftShow || newRightShow !== rightShow) {\n      setLeftShow(newLeftShow)\n      setRightShow(newRightShow)\n      onScrollStateChange?.(newLeftShow || newRightShow)\n    }\n  }, [leftShow, maxScrollLeft, onScrollStateChange, rightShow, scrollLeft])\n\n  const handleScroll = useCallback(() => {\n    if (ref.current === null) {\n      return\n    }\n    // 手動でスクロールが開始されたときにアニメーションを中断\n    if (animation.current) {\n      styles.scroll.stop()\n      animation.current = false\n    }\n    // スクロール位置を保存 (アニメーションの基準になる)\n    const manualScrollLeft = ref.current.scrollLeft\n    // 過剰にsetStateが走らないようにdebounceする\n    setScrollLeft(manualScrollLeft)\n  }, [animation, setScrollLeft, styles])\n\n  // リサイズが起きたときに、アニメーション用のスクロール領域 & ボタンの表示状態 を再計算する\n  const handleResize = useCallback(() => {\n    if (ref.current === null) {\n      return\n    }\n    const { clientWidth, scrollWidth } = ref.current\n    const newMaxScrollLeft = scrollWidth - clientWidth\n    setMaxScrollLeft(newMaxScrollLeft)\n    if (onResize) {\n      onResize(clientWidth)\n    }\n  }, [onResize])\n\n  useIsomorphicLayoutEffect(() => {\n    const elm = ref.current\n    const innerElm = innerRef.current\n    if (elm === null || innerElm === null) {\n      return\n    }\n\n    elm.addEventListener(\n      'wheel',\n      handleScroll,\n      passiveEvents() && { passive: true }\n    )\n\n    const resizeObserver = new ResizeObserver(handleResize)\n    resizeObserver.observe(elm)\n\n    const resizeObserverInner = new ResizeObserver(handleResize)\n    resizeObserverInner.observe(innerElm)\n\n    return () => {\n      elm.removeEventListener('wheel', handleScroll)\n      resizeObserver.disconnect()\n      resizeObserverInner.disconnect()\n    }\n  }, [handleResize, handleScroll])\n\n  // 初期スクロールを行う\n  useIsomorphicLayoutEffect(() => {\n    if (align !== 'left' || scrollOffset !== 0) {\n      const scroll = ref.current\n      if (scroll !== null) {\n        const scrollLength = Math.max(\n          0,\n          Math.min(\n            align === 'left' && scrollOffset > 0\n              ? scrollOffset\n              : align === 'center'\n              ? maxScrollLeft / 2 + scrollOffset\n              : align === 'right' && scrollOffset <= maxScrollLeft\n              ? maxScrollLeft - scrollOffset / 2\n              : 0,\n            maxScrollLeft\n          )\n        )\n        scroll.scrollLeft = scrollLength\n        setScrollLeft(scrollLength, true)\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [ref.current])\n\n  const handleScrollMove = useCallback(() => {\n    if (ref.current === null) {\n      return\n    }\n    if (onScroll) {\n      onScroll(ref.current.scrollLeft)\n    }\n  }, [onScroll])\n\n  const [disableGradient, setDisableGradient] = useState(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (isEdge()) {\n      setDisableGradient(true)\n    }\n  }, [])\n\n  // NOTE: Edgeではmaskを使うと要素のレンダリングがバグる（場合によっては画像が表示されない）のでグラデーションを無効にする\n  if (!disableGradient && options.hasGradient === true) {\n    const fadeInGradient = options.fadeInGradient ?? false\n    const overflowGradient = !fadeInGradient\n    return (\n      <Container ref={visibleAreaRef}>\n        <GradientContainer fadeInGradient={fadeInGradient}>\n          <RightGradient>\n            <LeftGradient show={overflowGradient || scrollLeft > 0}>\n              <ScrollArea\n                ref={ref}\n                scrollLeft={styles.scroll}\n                onScroll={handleScrollMove}\n              >\n                <CarouselContainer ref={innerRef} centerItems={centerItems}>\n                  {children}\n                </CarouselContainer>\n              </ScrollArea>\n            </LeftGradient>\n          </RightGradient>\n        </GradientContainer>\n        <ButtonsContainer>\n          <CarouselButton\n            direction={Direction.Left}\n            show={leftShow}\n            offset={buttonOffset}\n            bottomOffset={bottomOffset}\n            padding={buttonPadding}\n            gradient={overflowGradient}\n            onClick={handleLeft}\n          />\n          <CarouselButton\n            direction={Direction.Right}\n            show={rightShow}\n            offset={buttonOffset}\n            bottomOffset={bottomOffset}\n            padding={buttonPadding}\n            gradient\n            onClick={handleRight}\n          />\n        </ButtonsContainer>\n      </Container>\n    )\n  }\n\n  return (\n    <Container ref={visibleAreaRef}>\n      <ScrollArea\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        ref={ref}\n        scrollLeft={styles.scroll}\n        onScroll={handleScrollMove}\n      >\n        <CarouselContainer ref={innerRef} centerItems={centerItems}>\n          {children}\n        </CarouselContainer>\n      </ScrollArea>\n      <ButtonsContainer>\n        <CarouselButton\n          direction={Direction.Left}\n          show={leftShow}\n          offset={buttonOffset}\n          bottomOffset={bottomOffset}\n          padding={buttonPadding}\n          onClick={handleLeft}\n        />\n        <CarouselButton\n          direction={Direction.Right}\n          show={rightShow}\n          offset={buttonOffset}\n          bottomOffset={bottomOffset}\n          padding={buttonPadding}\n          onClick={handleRight}\n        />\n      </ButtonsContainer>\n    </Container>\n  )\n}\n\nconst CarouselContainer = styled.ul<{ centerItems?: boolean }>`\n  vertical-align: top;\n  overflow: hidden;\n  list-style: none;\n  padding: 0;\n\n  /* 最小幅を100%にして親要素にぴったりくっつけることで子要素で要素を均等に割り付けるなどを出来るようにしてある */\n  min-width: 100%;\n  box-sizing: border-box;\n\n  ${({ centerItems = false }) =>\n    centerItems\n      ? css`\n          display: flex;\n          width: max-content;\n          margin: 0 auto;\n        `\n      : css`\n          display: inline-flex;\n          margin: 0;\n        `}\n`\n\nconst ButtonsContainer = styled.div`\n  opacity: 0;\n  transition: 0.4s opacity;\n`\nconst Container = styled.div`\n  &:hover ${ButtonsContainer} {\n    opacity: 1;\n  }\n\n  /* CarouselButtonの中にz-index:1があるのでここでコンテキストを切る */\n  position: relative;\n  z-index: 0;\n`\n\nconst ScrollArea = styled(animated.div)`\n  overflow-x: auto;\n  padding: 0;\n  margin: 0;\n\n  &::-webkit-scrollbar {\n    display: none;\n  }\n\n  scrollbar-width: none;\n`\n\nconst GradientContainer = styled.div<{ fadeInGradient: boolean }>`\n  /* NOTE: LeftGradientがはみ出るためhidden */\n  overflow: hidden;\n  ${(p) =>\n    !p.fadeInGradient &&\n    css`\n      margin-left: ${-GRADIENT_WIDTH}px;\n      ${CarouselContainer} {\n        padding-left: ${GRADIENT_WIDTH}px;\n      }\n    `}\n\n  margin-right: ${-GRADIENT_WIDTH}px;\n  /* stylelint-disable-next-line no-duplicate-selectors */\n  ${CarouselContainer} {\n    padding-right: ${GRADIENT_WIDTH}px;\n  }\n`\n\nconst RightGradient = styled.div`\n  mask-image: linear-gradient(\n    to right,\n    #000 calc(100% - ${GRADIENT_WIDTH}px),\n    transparent\n  );\n`\n\nconst LeftGradient = styled.div<{ show: boolean }>`\n  /* NOTE: mask-position が left → negative px の時、right → abs(negative px) の位置に表示されるため */\n  margin-right: ${-GRADIENT_WIDTH}px;\n  padding-right: ${GRADIENT_WIDTH}px;\n  /* NOTE: mask-position に transition をつけたいが vender prefixes 対策で all につける */\n  transition: 0.2s all ease-in;\n  mask: linear-gradient(to right, transparent, #000 ${GRADIENT_WIDTH}px)\n    ${(p) => (p.show ? 0 : -GRADIENT_WIDTH)}px 0;\n`\n","import styled, { css } from 'styled-components'\nimport { unreachable } from '../../foundation/utils'\nimport NextIcon, { WedgeDirection } from '../icons/NextIcon'\nimport { applyEffect } from '@charcoal-ui/utils'\n\nexport enum Direction {\n  Right = 'right',\n  Left = 'left',\n}\n\ninterface Props {\n  direction: Direction\n  show: boolean\n  offset?: number\n  padding?: number\n  bottomOffset?: number\n  gradient?: boolean\n  onClick(): void\n}\n\nexport default function CarouselButton({\n  direction,\n  show,\n  offset = 0,\n  padding = 0,\n  bottomOffset: bottom = 0,\n  gradient = false,\n  onClick,\n}: Props) {\n  const offsetStyle =\n    direction === Direction.Left\n      ? {\n          left: gradient ? offset - 72 : offset,\n          paddingLeft: Math.max(padding, 0),\n          paddingBottom: bottom,\n        }\n      : {\n          right: gradient ? offset - 72 : offset,\n          paddingRight: Math.max(padding, 0),\n          paddingBottom: bottom,\n        }\n  return (\n    <Button\n      type=\"button\"\n      onClick={onClick}\n      hide={!show}\n      style={offsetStyle}\n      css={onlyNonTouchDevice}\n    >\n      <CarouselButtonIcon>\n        <NextIcon\n          direction={\n            direction === Direction.Right\n              ? WedgeDirection.Right\n              : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n              direction === Direction.Left\n              ? WedgeDirection.Left\n              : unreachable()\n          }\n        />\n      </CarouselButtonIcon>\n    </Button>\n  )\n}\n\nexport const CAROUSEL_BUTTON_SIZE = 40\n\nconst CarouselButtonIcon = styled.div`\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: ${CAROUSEL_BUTTON_SIZE}px;\n  height: ${CAROUSEL_BUTTON_SIZE}px;\n  border-radius: 50%;\n  background-color: ${({ theme }) => theme.color.surface4};\n  transition: 0.4s visibility, 0.4s opacity, 0.2s background-color, 0.2s color;\n  color: ${({ theme }) => theme.color.text5};\n`\n\nconst Button = styled.button<{ hide: boolean }>`\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  display: flex;\n  align-items: center;\n  padding: 0;\n  min-width: 40px;\n  border: none;\n  outline: 0;\n  background: transparent;\n  cursor: pointer;\n  transition: 0.4s visibility, 0.4s opacity;\n  /* つらい */\n  /* このコンポーネントはCarouselでしか使われてないのでそっちでコンテキストで切る */\n  z-index: 1;\n\n  &:hover ${CarouselButtonIcon} {\n    background-color: ${({ theme }) =>\n      applyEffect(theme.color.surface4, theme.effect.hover)};\n    color: ${({ theme }) => applyEffect(theme.color.text5, theme.effect.hover)};\n  }\n\n  &:active ${CarouselButtonIcon} {\n    background-color: ${({ theme }) =>\n      applyEffect(theme.color.surface4, theme.effect.press)};\n    color: ${({ theme }) => applyEffect(theme.color.text5, theme.effect.press)};\n  }\n\n  ${(p) =>\n    p.hide &&\n    css`\n      visibility: hidden;\n      opacity: 0;\n      pointer-events: none;\n    `}\n`\n\nexport function ScrollHintButton({\n  direction,\n  onClick,\n}: {\n  direction: Direction\n  onClick(): void\n}) {\n  return (\n    <ScrollHintIcon onClick={onClick}>\n      <NextIcon\n        direction={\n          direction === Direction.Right\n            ? WedgeDirection.Right\n            : // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            direction === Direction.Left\n            ? WedgeDirection.Left\n            : unreachable()\n        }\n      />\n    </ScrollHintIcon>\n  )\n}\n\nconst ScrollHintIcon = styled(CarouselButtonIcon)`\n  cursor: pointer;\n\n  &:hover {\n    background-color: ${({ theme }) =>\n      applyEffect(theme.color.surface4, theme.effect.hover)};\n    color: ${({ theme }) => applyEffect(theme.color.text5, theme.effect.hover)};\n  }\n\n  &:active {\n    background-color: ${({ theme }) =>\n      applyEffect(theme.color.surface4, theme.effect.press)};\n    color: ${({ theme }) => applyEffect(theme.color.text5, theme.effect.press)};\n  }\n`\n\nconst onlyNonTouchDevice = css`\n  @media (hover: none) and (pointer: coarse) {\n    display: none;\n  }\n`\n","import * as React from 'react'\nimport styled from 'styled-components'\n\nexport type IconSizes = 16 | 24 | 32\n\ninterface Props {\n  path: string | React.ReactNode\n  viewBoxSize: number\n  size?: IconSizes | 40 | 48 | 64 | 72\n  transform?: string\n  currentColor?: boolean\n  fillRule?: 'nonzero' | 'evenodd'\n  clipRule?: 'nonzero' | 'evenodd' | 'inherit'\n}\n\nexport default function IconBase({\n  size = 24,\n  viewBoxSize,\n  currentColor,\n  path,\n  transform,\n  fillRule,\n  clipRule,\n}: Props) {\n  return (\n    <Icon\n      viewBox={`0 0 ${viewBoxSize} ${viewBoxSize}`}\n      size={size}\n      currentColor={currentColor}\n    >\n      <IconBasePath\n        path={path}\n        transform={transform}\n        fillRule={fillRule}\n        clipRule={clipRule}\n      />\n    </Icon>\n  )\n}\n\nconst Icon = styled.svg<{ size: number; currentColor?: boolean }>`\n  stroke: none;\n  fill: ${({ currentColor = false, theme }) =>\n    currentColor ? 'currentColor' : theme.color.text2};\n  width: ${(props) => props.size}px;\n  height: ${(props) => props.size}px;\n  line-height: 0;\n  font-size: 0;\n  vertical-align: middle;\n`\n\ntype IconBasePathProps = Pick<\n  Props,\n  'path' | 'transform' | 'fillRule' | 'clipRule'\n>\nexport const IconBasePath = ({\n  path,\n  transform,\n  fillRule,\n  clipRule,\n}: IconBasePathProps) => {\n  if (typeof path === 'string') {\n    return (\n      <path\n        d={path}\n        transform={transform}\n        fillRule={fillRule}\n        clipRule={clipRule}\n      />\n    )\n  } else {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return <>{path}</>\n  }\n}\n"],"names":[],"sourceRoot":""}